# Default recipe - show list of available commands
_default:
    just list

# NOTE:
# Previous attempt at dynamic routing ('just <project> <command>') was removed because
# just does not support a true catch-all recipe that can safely intercept arbitrary
# top-level invocations without introducing invalid syntax or ambiguity.
#
# Recommended approaches for shorthand:
# 1. Shell function (add to your shell rc):
#      jp() { just run "pers/$1" "${@:2}"; }
#      # Usage: jp toolbox sleep-enable
#
# 2. Or alias for a single project (example):
#      alias jtb='just run pers/toolbox'
#
# Continue using the explicit 'run' recipe below.

list:
    #!/usr/bin/env bash
    set -euo pipefail
    BOLD=$'\033[1m'
    BLUE=$'\033[0;34m'
    GREEN=$'\033[0;32m'
    YELLOW=$'\033[0;33m'
    CYAN=$'\033[0;36m'
    GRAY=$'\033[0;90m'
    NC=$'\033[0m'

    find ~/proj/pers -maxdepth 4 -name "justfile" -type f \
        -not -path "*/.*" \
        -not -path "*/node_modules/*" \
        -not -path "*/target/*" \
        -not -path "*/.build/*" \
        -not -path "*/build/*" \
        2>/dev/null | sort | while read -r justfile_path; do

    rel_path="${justfile_path#$HOME/}"
    project_dir="${justfile_path%/justfile}"
    project_name="${project_dir##*/}"

    printf "${BOLD}${GREEN}üìÅ %s${NC} ${GRAY}(%s)${NC}:\n" "$project_name" "$rel_path"

    (cd "$project_dir" && just --list --unsorted 2>/dev/null) | \
        awk '/^    [a-zA-Z]/ { gsub(/^    /, ""); printf "  \033[0;36m%s\033[0m\n", $0 }' || \
        printf "  ${GRAY}(error reading commands)${NC}\n"
    echo ""
    done

    printf "${BOLD}${YELLOW}Usage:${NC}\n"
    printf "  ${CYAN}just run${NC} <project_path> <command> [args]\n\n"
    printf "${BOLD}${YELLOW}Suggested shell helper (add to ~/.zshrc or ~/.bashrc):${NC}\n"
    printf "  ${GRAY}jp() { just run \"pers/$1\" \"${@:2}\"; }${NC}\n\n"
    printf "${BOLD}${YELLOW}Examples:${NC}\n"
    printf "  ${GRAY}just run${NC} ${GREEN}pers/dotfiles${NC} ${CYAN}stow${NC}\n"
    printf "  ${GRAY}just run${NC} ${GREEN}pers/toolbox${NC} ${CYAN}sleep-enable${NC}\n"
    printf "  ${GRAY}just run${NC} ${GREEN}pers/toolbox/github${NC} ${CYAN}batch-close-issues${NC} ${YELLOW}'search-term'${NC}\n"

run path command *args:
    #!/usr/bin/env bash
    RED=$'\033[0;31m'
    GREEN=$'\033[0;32m'
    BLUE=$'\033[0;34m'
    GRAY=$'\033[0;90m'
    NC=$'\033[0m'

    target_dir="$HOME/proj/{{path}}"

    if [ ! -d "$target_dir" ]; then
    printf "${RED}‚ùå Directory not found:${NC} %s\n" "$target_dir"
    exit 1
    fi

    if [ ! -f "$target_dir/justfile" ]; then
    printf "${RED}‚ùå No justfile found in:${NC} %s\n" "$target_dir"
    exit 1
    fi

    printf "${BLUE}üèÉ Running:${NC} ${GREEN}just {{command}} {{args}}${NC} ${GRAY}in %s${NC}\n" "$target_dir"
    cd "$target_dir" && just {{command}} {{args}}

find-command command:
    #!/usr/bin/env bash
    BLUE=$'\033[0;34m'
    GREEN=$'\033[0;32m'
    RED=$'\033[0;31m'
    GRAY=$'\033[0;90m'
    NC=$'\033[0m'

    printf "${BLUE}üîç Searching for command${NC} '${GREEN}{{command}}${NC}' ${BLUE}in all justfiles:${NC}\n\n"

    found=false
    find ~/proj/pers -maxdepth 4 -name "justfile" -type f \
    -not -path "*/.*" \
    -not -path "*/node_modules/*" \
    -not -path "*/target/*" \
    -not -path "*/.build/*" \
    -not -path "*/build/*" \
    2>/dev/null | while read -r justfile_path; do

    rel_path="${justfile_path#$HOME/}"
    project_dir="${justfile_path%/justfile}"
    project_name="${project_dir##*/}"

    if (cd "$project_dir" && just --list --unsorted 2>/dev/null | grep -q "^    {{command}}"); then
        printf "${GREEN}‚úÖ Found in:${NC} %s ${GRAY}(%s)${NC}\n" "$project_name" "$rel_path"
        found=true
    fi
    done

    if [ "$found" = false ]; then
    printf "${RED}‚ùå Command${NC} '${GREEN}{{command}}${NC}' ${RED}not found in any justfile${NC}\n"
    fi
